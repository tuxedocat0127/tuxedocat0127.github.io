{"pages":[{"title":"About","text":"안녕하세요, Techlog를 운영하고 있는 최용득 입니다.삶을 살아가다 보면 좋아서 시작한 일들이 어느 순간부터 재미없고 귀찮아지는 순간들이 있습니다.저에게 있어서 개발자의 삶 역시 그런 순간들을 종종 마주하게 되는데요, 그런 순간들이 싫지만 동시에 제 삶을 돌아볼 수 있는 계기가 되는 것 같습니다.지금까지도 그랬지만 앞으로도 계속해서 개발 일을 좋아하고, 때로는 슬럼프도 마주하면서 자신을 되돌아보는 그런 삶을 살려고 노력하고 있습니다. document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"}],"posts":[{"title":"5분안에 Node.js 로컬호스트에 HTTPS 적용하기","text":"들어가는 글,지난번에 올린 HTTPS의 기본 개념에 이어 이번에는 https를 로컬호스트에 적용하는 방법에 대해 알아보겠습니다.최근 개발하는 서비스에서 중요한 유저 정보 및 카드 정보 등을 위해 https를 개발해야 하는 상황이 생겼습니다.보통은 node.js서버에 https를 적용하지만 역시 나 개발을 하려면 로컬 적용이 불가피합니다.일반적인 웹사이트 또는 서버에서 사용할 https에서는 Certification Authority(CA)가 필요하지만, 본 포스트에서는 임의로 certificate을 발급하는 방법과 trust 방법에 대해 알아보겠습니다.Root SSL Certificateopenssl 을 이용하여 우선 rootCA.key 를 생성하여야 합니다.아래의 커맨드를 입력하여 생성 가능하며, 생성도중에 passphrase를 물어보게 되는데 추후 key를 사용할때마다 입력되어야 하는 값이므로 잊어버리지 않도록 합니다..openssl genrsa -des3 -out rootCA.key 2048passphrase에 대한 자세한 내용위에서 생성된 key를 이용하여 이번에는 pem파일을 만들어줍니다. 아래에는 1024일동안 사용가능하며 원하는 기간만큼 숫자를 조정하면 됩니다.openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 1024 -out rootCA.pemCertificate Trust 처리임의로 생성된 certificate이기 때문에 브라우저에서는 믿을 수 없다고 처리됩니다. 따라서 호스트역할을 하는 (여기서는 Mac)서버에서 trust 처리를 해주어야 합니다.mac의 keychain access에서 방금 생성한 certificate을 찾아 always trust 처리를 해줍니다.keychain access여기에 생성한 certificate을 import 해준다면 위와 같이 등록이 되며, 더블클릭 후 trust에서 always trust로 처리 합니다.자 이제 거의 다 왔습니다.사실 이 상태로 certificate을 서버에 적용하여 돌려보면 HTTPS로 동작은 합니다만 여전히 브라우저에서는 Not Secure라고 표시됩니다.로컬에서 사용할 수 있도록 domain 설정하기방금전 certificate을 생성하였던 디렉토리에서 아래와 같은 파일을 생성합니다.cnf파일은 키 생성시 입력하였던 옵션값을 파일로 만들어 매번 생성 시 일일이 값을 입력하지 않도록 해줍니다.server.csr.cnf1234567891011121314[req]default_bits = 2048prompt = nodefault_md = sha256distinguished_name = dn[dn]C=USST=StateNameL=CityNameO=OrganizationNameOU=OrganizationUnitNameemailAddress=helloworld@gililab.comCN = localhostv3.ext1234567authorityKeyIdentifier=keyid,issuerbasicConstraints=CA:FALSEkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEnciphermentsubjectAltName = @alt_names[alt_names]DNS.1 = localhost생성이 완료되었다면 아래의 커맨드로 server.key와 crt파일을 생성합니다.openssl req -new -sha256 -nodes -out server.csr -newkey rsa:2048 -keyout server.key -config &lt;( cat server.csr.cnf )openssl x509 -req -in server.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out server.crt -days 500 -sha256 -extfile v3.ext생성된 certificate node.js 서버에 적용하기생성된 server.key와 server.crt파일을 프로젝트 폴더에 위치 시킵니다.저는 프로젝트 폴더 하위에 private 이라는 폴더를 생성하여 server.key와 server.crt파일을 옮겨 넣었습니다.이제 ssl 데이터를 가지고 있는 config 파일을 생성하여 줍니다.ssl-config.js12345const path = require('path');const fs = require('fs'); exports.privateKey = fs.readFileSync(path.join(__dirname, '../private/server.key')).toString();exports.certificate = fs.readFileSync(path.join(__dirname, '../private/server.crt')).toString();시스템마다 다르겠지만 서버의 호스팅 옵션값을 가지고 있는 파일에 아래와 같이 적용합니다.loopback framework을 사용하는 저 같은 경우는 config.local.js 파일에 적용하였습니다.config.local.js123456{ restApiRoot: '/api', host: process.env.HOST || '0.0.0.0', port: process.env.PORT || 80, url: 'https://localhost',}마지막으로 server.js에 https를 적용시켜줍니다.!server.js12345678910111213141516171819202122232425...const https = require('https');const sslConfig = require('../config/ssl-config');...const options = { key: sslConfig.privateKey, cert: sslConfig.certificate, passphrase: 'abcd' // certificate을 생성하면서 입력하였던 passphrase 값};...const app = module.exports;app.start = function () { // start the web server const server = https.createServer(options, app); return server.listen(app.get('port'), () =&gt; { app.emit('started'); const baseUrl = app.get('url') + ':' + app.get('port'); console.info('Web server listening at: %s', baseUrl); if (app.get('loopback-component-explorer')) { const explorerPath = app.get('loopback-component-explorer').mountPath; console.info('Browse your REST API at %s%s', baseUrl, explorerPath); } });};정상적으로 적용 되었습니다!마치는 글이렇게 해서 https certificate 생성 부터 Node.js에 적용하는 방법까지 알아보았습니다.certificate을 생성하는 과정은 다소 복잡해 보일 수 있으나 서버에 적용시키는 방법은 생각보다 많이 간단합니다.임의로 생성한 certificate은 안전하지 않으며 절대 실제 production에서는 사용하지 말길 바랍니다.질문이나 피드백이 있다면 언제든지 알려주세요 !Resourceshttps://www.freecodecamp.org/news/how-to-get-https-working-on-your-local-development-environment-in-5-minutes-7af615770eechttps://support.comodo.com/index.php?/Knowledgebase/Article/View/364/17/what-is-a-passphrase-and-how-can-i-change-the-passphrase-on-my-private-key-filehttps://loopback.io/doc/en/lb2/Preparing-for-deployment.html#create-the-https-serverhttps://support.comodo.com/index.php?/Knowledgebase/Article/View/364/17/what-is-a-passphrase-and-how-can-i-change-the-passphrase-on-my-private-key-filehttps://stackoverflow.com/questions/47957538/preparing-loopback-to-use-ssl document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Server/HTTPS/5%EB%B6%84%EC%95%88%EC%97%90-node-js-%EB%A1%9C%EC%BB%AC%ED%98%B8%EC%8A%A4%ED%8A%B8%EC%97%90-https-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"철수와 영희를 통해 알아보는 HTTPS 기본 개념","text":"들어개발자라면 누구나 HTTPS에 대해서 들어 보았을 것입니다. 굳이 개발자가 아니더라도 최근에 정부에서 유해사이트를 전면 차단 하면서 HTTPS를 통해 우회(?)접속까지 막혀 버려 많은 이슈가 되었습니다. ( 실제로 많은 청년들이 길거리에서 시위를 했다는…ㅋㅋㅋ )HTTPS에 대한 기본 개념들을 검색해 보면 아래와 같은 사진들이 자주 등장합니다.이미지 출처네트워크에 대한 지식이 어느정도 있으신 분이라면 금방 이해 하시겠지만.. 여전히 복잡해 보이는 건 마찬가지 입니다.이번 포스트에서는 HTTPS 통신 방법을 철수와 영희를 예시로 들어 알아보려고 합니다.HTTPS란 Hypertext Transfer Protocol Secure (기존 HTTP에 Secure를 뜻하는 S를 더함)의 약자로 정보를 주고받을때 암호화를 하여 통신하는 방식을 의미합니다.암호화 통신을 통해 중간에 해커로 부터 데이터를 탈취 당하더라도 내용을 알아볼 수 없다라는 이점이 있으며, 방문하는 블로그 등의 사이트에서 브라우저 정보를 수집 할 때도 HTTP통신에 비해 한정적인 데이터가 수집된다는 이점도 존재합니다.기존의 통신 방법기존 HTTP통신 방법에서는 암호화가 전혀 이루어지지 않았습니다.예를 들어, 철수와 영희가 연애편지를 주고받는다고 생각해 보겠습니다. 둘은 아날로스 방식으로 편지를 서로 주고받고 있는데 이 사이를 질투한 민수가 중간에서 편지를 훔쳐(탈취하여) 내용을 보고 수정을 한다면 어떻게 될까요 ?암호화나 보안 관련 작업이 전혀 이루어지지 않은 편지는 중간에 무슨일이 일어나도 철수와 영희는 이 사실조차 인지하지 못 할 것입니다. 그저 마음이 변해버린 영희를 그리워하는 철수만 남을 뿐.. (ㅠㅠ)이 문제를 해결하기 위해 등장한 방법이 대칭키 암호화(symmetric key cryptography) 방식입니다.대칭키 암호화대칭키 암호화 방식은 암호화 하는 키와 복호화 하는 키가 같아서 대칭키라는 이름이 붙었습니다.편지를 주고받던 철수와 영희는 그들만의 비밀편지를 누군가가 엿보는 것이 우려되기 시작하였습니다. 따라서 둘은 서로가 쓰는 편지를 남들이 알아볼 수 없도록 모든 글자를 3자리 앞에 존재하는 글자로 치환한 다음 편지를 보내고 (암호화) 받았을 때 역시 모든 글자를 3자리 뒤에 존재하는 글자로 치환(복호화)하여 보기로 하였습니다.예를 들어 D → A, E → B, F → C 이런 식으로 글자를 3자리씩 앞으로 옮긴다면 “secret message”는 “pbzobq jbppxdb”가 될 것입니다.이렇게 암호화키와 복호화키가 같은 경우를 대칭키 암호화라고 부릅니다.하지만 위의 방법에는 치명적인 단점이 있습니다. 우선 철수와 영희가 직접적으로 만나지 않는 이상 암호화/복호화 방법을 편지를 통해 주고 받아야 하는데 이 과정에서 이미 민수에게 내용이 노출될 수 있다는 점과 평소 암호학을 공부하던 민수는 이렇게 간단한 암호화 기법은 손쉽게 풀어 버릴 수 도 있기 때문입니다.따라서 이를 우려한 철수와 영희는 비대칭 암호화(asymmetric key cryptography) 방식을 통하여 서로 비밀 편지를 주고 받도록 합니다..비대칭키 암호화철수와 영희는 다음와 같은 방법을 생각해 냅니다.철수는 영희에게 아무것도 적혀있지 않는 편지를 먼저 보낸다.영희는 잠겨있지 않는 박스에 박스 열쇠를 넣어 다시 철수에게 보낸다.철수는 박스에 편지를 담은 후 박스를 잠그고 해당 박스를 영희에게 보낸다.영희는 박스를 열어 편지를 확인한다.위의 방법은 암호화와 복호화의 키가 서로 같지 않기 때문에 비대칭키 암호화라고 불립니다. 왜냐하면 박스를 중간에 가로채어 닫는 데는 성공 하여도 닫혀 있는 박스를 열수는 없기 때문입니다.여기서 박스는 공개키(public key)가 되는 것이고, 박스를 여는 열쇠는 비공개키(private key)가 됩니다.여기서의 또다른 문제점이미 눈치채신 분도 계시겠지만 여기서 철수가 박스를 받았을 때 어떻게 영희가 보낸 박스 인지 믿을 수 있을까요 ?영희는 따라서 자신이 보낸 박스가 맞다는 서명을 함께 동봉하여 철수에게 보내기로 하였습니다.하지만 영희의 서명을 한번도 본적이 없는 철수는 여전히 민수가 보낸 박스 인지 의심할 수 밖에 없는 상황입니다.여기서 철수와 영희는 모두가 다 알고, 믿을만한 사람인 선생님께 박스에 서명을 하도록 부탁 하기로 합니다.선생님은 박스를 받았을 때 영희가 준 것을 확인한 후에야 박스에 서명을 해주기로 약속합니다. 여기서 선생님의 역할을 Certification Authority (CA)라고 부릅니다.선생님의 서명을 알고 있던 철수는 영희가 보낸 박스가 맞다는 사실에 안도하며 둘만의 안전한(?) 비밀편지를 주고 받을수 있게 되었습니다.이미지 출처끝으로,,HTTPS의 통신 방법을 철수와 영희의 예시로 들어 보았습니다. 실제로 HTTPS가 적용되어 있는 웹페이지에 접속한다면 선생님의 역할 이였던 CA의 서명과 정보가 함께 동봉되어 브라우저로 전달이 됩니다.HTTP에 비해서 절차가 많고 암호화가 되는 등 웹페이지가 상대적으로 느려지는 단점이 존재합니다. 따라서 실제로는 비대칭키 암호화는 암호화키를 주고 받을때 만 사용됩니다.긴 글 읽어 주셔서 감사합니다.잘못된 내용이 있거나 수정해야 할 내용이 있다면 언제든지 알려주세요.!Resourceshttps://medium.com/free-code-camp/https-explained-with-carrier-pigeons-7029d2193351https://www.thesslstore.com/blog/what-happens-when-your-ssl-certificate-expires/https://love2dev.com/blog/how-https-works/ document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Server/HTTPS/%EC%B2%A0%EC%88%98%EC%99%80-%EC%98%81%ED%9D%AC%EB%A5%BC-%ED%86%B5%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-https-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90/"},{"title":"Wireshark로 HTTPS 암호화 검증하기","text":"최근 HTTPS 관련 작업을 하다가 문득 정말로 암호화가 되기는 하는 걸까? 라는 의문이 들기 시작하였습니다.(사실 HTTPS를 적용하는 방법이 너무 간단해서 더 의심이 됐다는..)이론상으로는 비대칭키를 이용한 암호화 통신을 통해 중간에서 정보가 탈취 되더라도 알아볼 수 없다 라고는 하는데 여전히 의구심이 들어 직접 확인해 보기로 했습니다.WiresharkWireshark(와이어샤크)란 오픈 소스 패킷 분석 프로그램입니다. 현재 내 컴퓨터에서 주고받는 네트워크 패킷을 캡쳐 해서 세부 내용들을 확인해 볼 수 있으며 직접적인 연결 뿐만 아니라 브로드캐스트, 멀티캐스트 등의 내용도 확인할 수 있습니다.실제로 컴퓨터에 연결된 케이블에서 무슨 일이 일어나는지 알아낼 수 있는 아주아주아주 중요하고 좋은 툴입니다.과거 보안 관련 일을 할 때 DDOS바이러스에 걸린 컴퓨터가 특정 IP로 heartbeat(서버에 클라이언트가 살아있다는 정보)를 보내는 패킷을 캡쳐 해서 무슨 정보를 주고받고 있으며, 해당 컴퓨터 내 무슨 프로세스가 바이러스로 동작 하는지 파악할 수 있었습니다.이제 본론으로 들어가자면,,HTTP 방식 GET REQUEST먼저 HTTP로 통신하는 API서버에 GET REQUEST를 해보겠습니다. 통신 순서는 단순하게 클라이언트에서 GET REQUEST를 보내면 서버에서 해당 값을 RESPONSE해주는 1차원 적인 방식입니다.테스트용으로 만든 API서버에 HTTP GET REQUEST를 해보았습니다.결과의 첫번째 줄은 클라이언트 → 서버 REQUEST, 두번째 줄은 서버 → 클라이언트 RESPONSE입니다클라이언트 → 서버 GET REQUEST 패킷을 열어 보면 다음과 같이 어느 URL로 무슨 정보를 REQUEST했는지 볼 수 있습니다. 그 이외에도 네트워크 관련 많은 정보들을 보여주는데 이는 추후 Wireshark에 관련해서 별도로 다뤄 보도록 하겠습니다.간혹 가다가 HTTP에서 header나 post를 이용하여 accessToken과 같은 중요한 정보를 숨기면 되지 않느냐는 질문을 하시는 분들이 계시는데 이는 URL에서만 보이지 않을 뿐 보안 적인 기능을 전혀 하지 않는 방법입니다.실제로 테스트용 API서버는 accessToken을 header로만 주고받도록 되어 있는데 위와 같이 모든 정보들이 그대로 보여 지게 됩니다.다음은 서버 → 클라이언트 RESPONSE내용 입니다. JSON형식으로 반환되는 데이터들이 key-value 별로 아주 예쁘게(?) 정리되어 있습니다.ㅎㅎHTTPS 통신 방식HTTPS의 통신 방식은 다음과 같습니다.이미지 출처서버와 클라이언트에서 서로 인증서와 키를 주고 받은 다음 암호화된 데이터로 통신을 하는 방식이며, HTTPS 통신에 대한 기본 개념에 대해 잘 모르시는 분들은 이전포스트 를 확인해 주세요.HTTPS 방식 GET REQUESTHTTPS로 동일한 API에 GET REQUEST를 해보았습니다.가장 먼저 보이는 차이점은 Protocol이 이전에는 HTTP였다면 지금은 TCP와 TLS로만 통신을 하게 됩니다.위에서 부터 순서대로 서버와 클라이언트가 인증서와 키를 주고받은 다음 암호화 통신에 필요한 기본적인 정보들을 주고 받게 됩니다. HandShake 까지 완료가 되면 그 뒤로 REQUEST 와 RESPONSE가 진행됩니다.Application Data 패킷을 열어 보면 Port 역시 HTTP가 사용하는 80포트가 아닌 443 포트를 사용하는 것을 볼 수 있으며, 모든 내용은 예상과 같이 암호화가 되어 보여 집니다.마치는 글이렇게 실제로 HTTPS가 암호화되어 통신을 하는지 확인해 보았습니다.예전 같았으면 당연히 내부적으로 잘 동작 하겠지 라고 생각했겠지만 최근들어 당연한 것도 한번 더 확인해 보는 습관이 생긴 것 같습니다. 조금 귀찮긴 하지만 자세히 확인해보면 몰랐던 내용도 많이 알 수 있어서 좋은 경험이 된 것 같습니다.질문이나 피드백이 있다면 언제든지 연락 주세요 .!Resourceshttps://www.wireshark.org/docs/wsug_html_chunked/ChapterIntroduction.html#ChIntroWhatIs document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Server/HTTPS/wireshark%EB%A1%9C-https-%EC%95%94%ED%98%B8%ED%99%94-%EA%B2%80%EC%A6%9D%ED%95%98%EA%B8%B0/"},{"title":"var, let or const 무엇을 써야 할까 ?","text":"모든 예제 코드는 Github에서 확인 가능합니다.좋은 개발자란 무엇이라고 생각하시나요? 정답은 없겠지만 굳이 고르자면 코드를 간결하고 누가 봐도 작성자의 의도를 파악하기 쉽게 작성하는 개발자가 좋은 개발자라고 생각합니다.개발을 하다보면 종종 잠깐 쓰이다 말 변수인데 새로 선언하기도 귀찮고 특히나 이름 짓기가 너무 어려워서 그냥 하나의 변수를 다용도로 사용하고 싶어 지는 유혹(?)이 올 때가 있습니다. 하지만 이런 식의 변수 사용은 코드 작성자의 의도를 파악하기 어려울 뿐만 아니라 유지 보수에도 많은 시간과 비용이 들게 됩니다.따라서 이런 상황을 피하기 위해 자바스크립트 ES6에서 부터 제공되는 const 사용을 지향해야 합니다.constconst 변수의 특징은 처음 선언과 동시에 할당이 되면 재 할당이 불가능합니다.12345const number = 1;number = 2;Output:&gt;TypeError: Assignment to constant variable.const를 기능적으로 바라보았을 땐 단순히 변수의 재할당이 불가능하다 이지만 const를 사용한다는 뜻은 하나의 변수는 하나의 기능만 한다는 뜻을 내포하고 있습니다.다른 개발자가 const로 선언한 변수와 변수명을 보면 해당 변수는 하나의 목적을 위해 만들어졌다는 것이 파악되기 때문에 협업과 유지 보수에 있어서 많은 이점을 가져올 수 있습니다.const 예외한번 할당한 const의 경우 값의 수정이 불가능 하지만 예외는 존재합니다(변경이 안된다면서 이건 또 뭔 소리야 ?)12345678910111213const person = { name: 'Daniel', age: 28,};person.name = 'Andrew';const people = []people.push(person)console.log(person, people)Output:{ name: 'Andrew', age: 28 } [ { name: 'Andrew', age: 28 } ]integer, string 과 같은 JS의 기본 타입을 할당한 경우 변경이 불가능하지만 call by reference 를 사용하는 object나 array 같은 경우는 자유롭게 값을 수정할 수 있습니다.변수가 선언되고 나면 object나 array의 경우 변수는 해당 값의 메모리 주소를 가지고 있기 때문에 실제로 object내 값의 변화에 대해서는 관여하지 않게 됩니다.많은 분들이 const가 constant 또는 immutable이라고 생각하지만 위와 같은 성질 때문에 완전한 immutable이라고 말할 수는 없습니다.const 를 immutable로 사용하기ES5부터 지원되는 Object.freeze()를 이용하면 const object를 immutable변수 할당이 가능합니다.123const foo = Object.freeze({ 'bar': 27 });foo.bar = 42; // TypeError exceptionconsole.log(foo.bar);또는, immutable.js 와 같은 라이브러리를 통해 해결 가능합니다.그렇다면 var과 let의 차이는?항상 const 변수만 사용하면 좋겠지만, const를 사용할 수 없는 경우가 종종 오기도 합니다.for문 안에서 써야 하는 경우나, 복잡한 수학 공식을 계산하는 경우 등 변수 값이 계속해서 바뀌어야 하는 경우는 let을 사용하면 됩니다.var 과 let 둘 다 한번 선언하고 여러번 할당이 가능한 변수지만 둘의 가장 큰 차이점은 var은 function scoped 변수이고, let은 block scoped인 변수라는 점 입니다.예제112345678Input:console.log(x);var x=5;console.log(x);Output:undefined5예제1 var의 경우 변수가 선언이 되지 않았지만 호출이 된다면 현재 scope에서 해당 변수명이 존재하는지 찾고 없다면 다시 상위에서, 또 없다면 그 상위에서 찾으며 scope를 한 단계씩 올라가며 찾게 됩니다.예제21234567Input:console.log(x);let x=5;console.log(x);Output:ReferenceError: x is not defined하지만 예제2 let의 경우 선언과 할당이 이루어진 후에 해당 블록 내에서만 사용이 가능합니다.123456789101112for(var i=0; i&lt;10; i++){ console.log(i); // Output: 0, 1, 2, ... 9}console.log(i); // Output: 10const i = 1; // SyntaxError: Identifier 'i' has already been declaredfor(let j=0; j&lt;10; j++){ console.log(j); // Output: 0, 1, 2, ... 9}console.log(j); // ReferenceError: j is not definedconst j = 1; // 정상적으로 변수선언 가능var과 let 비교의 또다른 예제 입니다.첫번째 for문에서 선언된 var i 는 for문 밖에서도 사용이 가능하며 이후 i 를 선언한 경우 이미 선언된 변수라는 에러 메시지를 출력합니다.두번째 for문에서 선언된 let의 경우 for문 안에서는 정상 동작하지만 for문을 벗어난 시점 부터 존재하지 않는 변수로 처리됩니다.let을 사용한다는 뜻은 해당 변수의 값이 변경 될 수 있지만, 변수가 선언된 블록 내에서만 사용 한다는 뜻을 내포하고 있습니다. 따라서 const를 사용할 수 없는 상황이라면 let을 사용하는 것이 좋습니다.끝으로불가피한 상황이 아닌 이상 항상 const를 사용하는 것이 좋습니다. 추후에 다루어 볼 내용이지만, 함수형 프로그래밍 (Functional Programming) 형태로 코드를 작성하게 되는 경우 변수를 재할당해야 하는 대부분의 상황을 해결 할 수 있습니다. :)Resourceshttps://medium.com/javascript-scene/javascript-es6-var-let-or-const-ba58b8dcde75https://github.com/goldbergyoni/nodebestpractices#-37-prefer-const-over-let-ditch-the-varhttps://www.geeksforgeeks.org/difference-between-var-and-let-in-javascript/https://mathiasbynens.be/notes/es6-const document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Javascript/General/var-let-or-const-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%8D%A8%EC%95%BC-%ED%95%A0%EA%B9%8C/"},{"title":"자바스크립트 비동기통신 Callback, Promise, Async/Await 이해하기","text":"모든 예제 코드는 Github에서 확인 가능합니다.자바스크립트를 공부하다 보면 항상 Promise와 Async/Await 관련 글들을 많이 보게 되는데요.자주 쓰이고 중요한 내용들이지만 많은 저를 포함해 많은 분들이 햇갈려 하거나 아직 정확히 개념이 안 잡혀 있는 경우가 많습니다. 이번 포스트에서는 기본적인 비동기 통신 개념부터, Callbacks, Promises, Async/Await에 대해 알아보겠습니다.자바스크립트는 다른 언어들과는 다르게 싱글 스레드(Single Threaded Language)를 사용하는 언어입니다. 다시 말해서 자바스크립트는 한번에 한 개의 일만 순차적으로 처리할 수 있습니다.병렬 처리를 할 수 없는 자바스크립트는 기존 병렬 처리가 필요한 작업들을 “asynchronous non-blocking I/O model“ 이라는 방식을 통해 해결하고 있습니다. 프로그램이 실행되는 동안 서버로 부터 정보를 불러오거나, 데이터베이스에서 데이터를 가져와야 하는 경우 실행 되던 프로그램이 잠시 멈추고 I/O operation들이 해당 작업을 처리한 후 다시 작업을 계속해 나가는 방식으로 처리됩니다.언어 자체는 병렬처리가 불가능 하지만 자바스크립트를 해석하고 실행하는 엔진에서는 I/O관련 작업들을 내부적으로 병렬 처리를 하게 됩니다.Callbacks자바스크립트에서는 함수가 받아들이는 값을 int, string 형 뿐만 아니라 함수로도 받아들일 수 있습니다. 인자로 받아들인 함수를 다시 호출하는 기능을 callback이라고 부릅니다.Callback 예제1234567function add5(a, callback) { setTimeout(() =&gt; callback(a + 5), 100)// 100ms가 지난 후 함수로 입력받은 callback에 a + 10값을 다시 입력하여 callback함수 호출}add5(10, function (res) { // add5가 입력받는 callback함수 정의 부분 console.log(res)});add5를 호출하는 부분을 보시면 첫 번째 인자로 숫자 5, 두 번째로는 함수를 생성하여 전달하는 것을 볼 수 있습니다. add5 함수 내부에서는 입력 받은 함수 callback에 a + 5를 하여 다시 호출하게 됩니다.Callback HellCallback이란 처음엔 조금 어렵지만 한번 이해하게 되면 굉장히 편한 기능입니다. 하지만 callback은 연속적으로 사용하게 되면 유지보수가 힘들어 진다는 치명적인 단점이 존재합니다이번에는 위의 예제에서 만든 add5를 연속적으로 호출하여 10에 5 + 5 + 5 + 5 를 하는 코드입니다.123456789add5(10, res =&gt; { add5(res, res =&gt; { add5(res, res =&gt; { add5(res, res =&gt; { console.log(res) }) }) })})단순히 더하기만 하는 코드지만 함수를 재귀적으로 여러번 호출하기 때문에 다소 복잡해 보입니다.실제로 로그인 기능을 구현할 때 로그인 정보를 받아들여 비밀번호를 확인하고, 옳다면 유저 정보를 가져오고 틀리다면 에러 메시지를 출력하는 등 if-else문이 callback 중간 중간에 들어가야 하는 경우가 자주 있습니다.따라서 callback을 4번5번 연속적으로 호출하게 될 경우 callback hell 을 맛보실 수 있게 됩니다. 하하PromisesPromise란 기본적으로 callback이 하는 일과 같습니다. 다만 차이점이라면 Promise는 작업이 끝난 후 실행할 함수를 제공하는 것이 아니라 Promise 자체 메소드인 .then()을 호출하게 됩니다.Promise 특징123456789function add10(a) { return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(a + 10), 100));} //Promise사용 시 작업이 끝났음을 알려주는 resolve를 인자로 받아들임.add10(10) .then(add10) .then(add10) .then(add10) .then((res) =&gt; console.log(res))Promise는 then()과 같은 메소드를 연속적으로 사용이 가능한 이점을 가지고 있습니다. 따라서 callback을 사용했을 때와는 다르게 코드를 작성하고 이해하기가 한결 쉬워졌습니다.!이처럼 메소드를 연속적으로 사용하는 chaining이 가능한 이유는 add10 함수가 결과값을 Promise로 리턴하기 때문입니다. 실제로 add10의 결과값을 출력해보면 값이 다음과 같이 출력되는 것을 볼 수 있습니다.12console.log(add10(10));&gt;&gt; Promise { &lt;pending&gt; }Promise에서의 예외 처리12345add10(10) .then((res) =&gt; { throw 'test error'; }) .catch((err) =&gt; console.log(err));Promise에서는 작업이 실패하였을 경우 자동으로 .catch() 메소드가 호출되게 됩니다. 따라서 callback과 같이 함수 호출 중간에 if-else를 사용하는 것이 아닌 .catch()로 한번에 해결할 수 있는 장점이 있습니다.12345678try { add10(10) .then((res) =&gt; { throw 'test error'; })} catch(err) { console.log(err)}기존 try-catch를 이용해서도 예외 처리가 가능하지만 자바스크립트에서는 Promise의 catch를 사용 하라는 warning message를 출력하게 됩니다.Async/AwaitNodeJs 버전 7.6부터 구현된 기능이며 Async/Await를 사용하면 Promise에 비해 보다 쉽게 비동기적인 상황을 표현할 수 있습니다.123456async function f1() { const a = await add10(10); const b = await add10(a); console.log(a, b)}f1();Async와 Await을 사용하려면 우선 사용할 함수 앞에 async라는 키워드를 붙여 사용해야 하며 선언된 async 함수 안에서만 await 키워드를 사용할 수 있습니다.await은 함수의 작업이 끝나고 결과값을 반환할 때까지 대기하게 되며 결과 값이 리턴된다면 다음 작업으로 넘어가게 됩니다.Async/Await에서의 예외 처리123456async function f2() { const a = await add10(10).then(res =&gt; res); const b = await add10(a).catch(err =&gt; err); console.log(a, b)}f2();위의 예제에서는 add10이 Promise를 리턴하므로 Promise가 지원하는 메소드들을 바로 사용할 수 있습니다. 따라서 .catch()를 이용하여 예외 처리가 가능합니다.12345678910async function f3() { try { const a = await add10(10) const b = await add10(a) console.log(a, b) } catch(err) { console.log(err) }}f3();또는 기존과 같은 방식의 try-catch를 이용한 예외 처리를 할 수 있습니다.끝으로이렇게 callback, Promise 그리고 async/await에 대해 알아보았습니다.async와 await이 코드 작성 시 조금 더 동기적으로 보일 수 있지만 callback이나 promise 형태의 API를 사용하게 된다면 내부적으로는 Promise와 동일하게 I/O Operator 들에 의해 병렬적으로 동작하게 되며 비동기 테스크들이 끝나고 결과값을 반환할 때까지 그 이후의 코드들을 실행하지 않고 기다리게 됩니다.개인적으로는 async/await 역시 Promise에 비해 코드 작성이 편하다고 생각이 들지만 예외 처리나 테스크들을 작성함에 있어서 약간 불편하다는 생각이 듭니다. 따라서 저는 async라는 외부 라이브러리를 자주 사용합니다.async에 관한 내용은 다음 포스트에서 다루어 보도록 하겠습니다.긴 글 읽어주셔서 감사하며 피드백이나 수정사항이 있다면 언제든지 연락 주세요.Resourceshttps://dev.to/farahanjum/callbacks-promises-in-javascript-2b6https://medium.com/codebuddies/getting-to-know-asynchronous-javascript-callbacks-promises-and-async-await-17e0673281ee document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Javascript/General/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%B9%84%EB%8F%99%EA%B8%B0%ED%86%B5%EC%8B%A0-callback-promise-async-await-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/"},{"title":"Nginx에 HTTPS SSL 적용하기","text":"앞선 포스트들에서 기본적인 HTTPS개념들과 동작 방식, 그리고 로컬 API서버에 적용하는 방법을 다루어 보았습니다. 이번에는 Nginx를 기반으로 작동하는 웹 서버에 HTTPS를 적용하는 방법에 대해 알아보겠습니다.HTTPS키 발급 받기HTTPS를 적용하기 위해서는 CA(Certification Authority)로 부터 certificate을 먼저 발급받아야 합니다.국내에서는 후이즈, 가비아 등 에서 구매를 하실 수 있습니다. 다만 후이즈, 가비아에서도 외국의 업체를 통해서 certificate을 사는 방식이고 가격 또한 상대적으로 비싼편이기 때문에 해당 사이트에 직접 접속하셔서 구매하는 것을 추천 드립니다.저 같은 경우에는 sectigo에서 가장 기본 사양으로 구매 하였으며 가격은 2020년 현재 10.98불 입니다.발급된 키 공개키/비공개키 만들기 (Optional)구매가 완료 되셨다면 HTTPS 적용에 사용될 파일들이 제공됩니다.우리가 사용할 파일은 크게 4가지로 존재합니다root.crt.pem (Root 파일)chain1.crt.pem (Chain1 파일)chain2.crt.pem (Chain2 파일)domain.crt.pem (서버 인증서)domain.key.pem (비공개 키)업체마다 다르지만 위의 키 들이 나누어져 있는 곳도 있고, 하나의 bundle파일로 합쳐져 있는 곳도 있습니다. bundle파일이 존재한다면 바로 사용하셔도 되고, 저와 같이 각각 따로 존재한다면 병합하는 작업이 필요합니다.순서대로 서버 인증서, Chain1, Chain2, Root 파일을 unified.domain.pem 파일로 병합하여 줍니다. ( 파일명은 크게 중요하지 않습니다)여기서 순서가 어긋나게 되면 인증서 사용이 안되기 때문에 반드시 순서를 지켜 주시기 바랍니다.1cat doamin.crt.pem chain1.crt.pem chain2.crt.pem root.crt.pem &gt; unified.domain.pemNginx에 HTTPS적용하기이제 거의 다 왔습니다. 위에서 병합한 파일 unified.domain.pem 과 domain.key.pem 을 사용하여 HTTPS를 적용시키면 끝납니다.Nginx가 이미 설치되었다는 가정 하에 conf 파일을 수정하여 줍니다.conf1234567891011121314server { listen 443 ssl default_server; ssl on // deprecated from Nginx v1.15 server_name example.com ssl_certificate /directory/to/unified.domain.pem // 병합한 파일 ssl_certificate_key /directory/to/domain.key.pem // 비공개 키 ssl_protocols TLSv1.1 TLSv1.2; location / { root /home/ubuntu/web/dist/; index index.html index.htm index.nginx-debian.html; try_files $uri $uri/ /index.html; }}위와 같이 설정을 해주면 됩니다.여기서 중요한 점은 본인의 웹 사이트가 www 를 사용한다면 이곳에서도 www 를 반드시 넣어 주어야 하며, certificate을 구매할 때 역시 domain을 물어보게 되는데 이곳에서도 www 를 반드시 입력하셔야 합니다. 저는 www 사용을 지양하고 있기 때문에 domain 구매 시 입력한 주소와 nginx에 입력되는 주소에서 제외하도록 하였습니다.위의 과정이 끝났다면 sudo nginx -t 를 통해 설정 파일이 제대로 작성 되었는지 확인 후 nginx -s reload 명령어를 통하여 설정 파일을 로드 하여 줍니다.HTTP접속을 HTTPS로 리다이렉션 시키기HTTPS적용은 끝났지만 기존의 사용자들은 웹 접속 기록 때문에 여전히 http로 접근을 하게 됩니다. 따라서 http로 접속되는 세션들을 HTTPS로 리다이렉션을 시켜 주어야 합니다.Nginx conf 파일 상단에 아래와 같은 코드를 적용하여 줍니다.conf12345server { listen 80; server_name example.com; return 301 HTTPS://$server_name$request_uri;}기타 이슈 사항들key values mismatch 이슈아래와 같은 이슈사항이 있는 경우 비공개 키 값이 손상 되었거나 파일들을 unified.domain.pem 으로 병합을 잘못시킨 경우 나타나는 애러입니다.SSL: error:0B080074:x509 certificate routines:X509_check_private_key:key values mismatch파일을 다시 다운로드 하여서 병합 과정을 다시 진행하면 해결할 수 있습니다.bad end line 이슈PEM_read_bio_X509() failed (bad end line)위의 이슈는 파일들을 병합하는 과정에서 줄바꿈이 안된 경우 발생하는 문제입니다.unified.domain.pem123456789-----BEGIN CERTIFICATE-----(Base64)-----END CERTIFICATE----------BEGIN CERTIFICATE-----(Base64)-----END CERTIFICATE-----간단하게 줄바꿈을 통하여 해결할 수 있습니다.끝으로,HTTPS를 실제 웹 서버에 적용시키는 방법을 알아보았습니다.다소 복잡해 보이는 HTTPS동작 방식을 다 이해하지 않아도 천천히 따라 하시면 쉽게 적용할 수 있습니다.피드백이나 질문사항이 있다면 언제든지 연락주세요 ! document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Server/HTTPS/nginx%EC%97%90-https-ssl-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"async라이브러리에 대해 알아보자","text":"모든 예제 코드는 Github에서 확인 가능합니다.자바스크립트에서 기본적으로 제공하는 async/await을 통해 대부분의 비동기 작업에 대해 간단하게 구현이 가능합니다. 하지만 연속적으로 병렬 작업을 처리해야 하거나 하나의 함수에서 반환된 값을 다른 함수에 적용하는 등 다양한 플로우에 대해 개발자가 매번 구현해야 하는 번거로움이 존재합니다.async 라이브러리는 비동기적인 병렬 처리, chaining, 분기문, 반복 처리 등에 대해 직관적이며 간단한 기능들을 제공합니다.async 설치패키지 매니저를 통해서 간단하게 설치할 수 있습니다.1npm install asyncasync의 유용한 기능들async의 몇몇 메소드를 제외한 대부분은 테스크가 끝났음을 알려주는 callback 함수를 제공합니다. callback 함수의 첫 번째 인자는 항상 error 값이 들어가야 하며 두번째 인자는 전달하려는 결과값이 들어갑니다. error가 없으면 null로 입력해도 되고, 전달하려는 결과값이 없는 경우 그냥 callback() 을 호출하는 식으로 처리할 수 있습니다.parallel개인적으로 가장 많이 사용하는 병렬처리 메소드 입니다. 아래와 같이 배열에 처리하고 싶은 비동기 작업들을 callback 을 인자로 받는 함수 형태로 선언합니다. 100ms 이후에 전달받은 값에 10을 더하는 함수를 병렬로 실행하는 코드입니다.123function add10(a, callback) { //100ms 이후 10을 더한값을 callback에 입력 setTimeout(() =&gt; callback(null, a + 10), 100);}1234567891011const tasks = [ // 병렬처리할 함수들 정의 callback =&gt; add10(10, callback), callback =&gt; add10(10, callback), callback =&gt; add10(10, callback)];async.parallel(tasks, (err, results) =&gt; { // 병렬 실행 후 err와 results를 반환 console.log(err, results);});Output:null [ 20, 20, 20 ] // err가 없으므로 null이 반환됨동작 방식은 다음과 같습니다async.parallel이 실행되면 tasks 배열에 들어있는 작업들이 병렬로 실행되게 됩니다. 각각의 작업은 함수로 선언되어 있으며 callback을 인자로 받아들입니다. add10에서 작업이 완료되면 결과값을 callback에 넣어 호출함으로써 작업이 끝났음을 async에 알립니다.각 task를 처리하는데 시간이 조금씩 다르게 걸리며 마지막 task까지 callback을 호출하게 된다면 결과값을 async.parallel의 2번째 인자로 전달합니다.작업 실행 도중 문제가 없었다면 error는 null로 반환되며 results에는 tasks 내에 정의된 작업의 순서에 맞게 결과값을 배열로 전달합니다.waterfall이번에 알아볼 메소드는 waterfall입니다. 이름에서 이미 짐작하셨겠지만 정의된 작업들의 결과가 다음 작업으로 전달되면서 순차적으로 처리되는 방식입니다.아래의 예시는 순차적으로 add10을 실행하여 10을 누적하여 더하는 코드입니다.1234567891011const tasks = [ (callback) =&gt; add10(10, callback), (res, callback) =&gt; add10(res, callback), // res는 tasks의 0번째 배열에서 넘겨받은 결과값 (res, callback) =&gt; add10(res, callback) // res는 tasks의 1번째 배열에서 넘겨받은 결과값];async.waterfall(tasks, (err, results) =&gt; { console.log(err, results); // 최종 결과값 출력});Output:null 40tasks에 정의된 작업들을 순차적으로 처리해 나갑니다. 0번째 배열은 이전 작업이 없기 때문에 인자를 callback만 받아들이며 1번째 배열부터 이전 배열에서 처리한 데이터를 넘겨받습니다.waterfall은 회원가입 시 순차적으로 아이디 비밀번호를 확인하고 결과값을 가지고 회원정보를 확인 후 반환하는 등 대부분의 순차적인 작업에 적합한 메소드입니다.each배열에 정의된 작업들을 반복적으로 처리해야 하는 경우 async.each를 사용하시면 됩니다.12345678910111213141516171819202122232425const tasks = [ // 반복적으로 처리해야하는 함수나 값 선언 add10, add10, add10, add10, add10,];// async.each의 두번째 인자는 tasks에서 하나씩 가져온 각각의 task와 callbackasync.each(tasks, (eachTask, callback) =&gt; { eachTask(10, (err, result) =&gt; { console.log(result); callback(err); // 작업이 끝났음을 알림 })}, (err) =&gt; { // 위의 반복문이 모두 실행되면 마지막으로 err를 인자로 받는 함수 실행 console.log(err)});Output:2020202020null반복적으로 비동기적인 업무를 처리할 때 아주 좋은 함수입니다.만약 1만 개의 유저 데이터가 배열에 들어가 있고 각각의 유저에 대해 유저 프로필을 호출한 다음 특정 값을 입력해야 하는 등의 작업을 처리할 때 유용합니다.여기서 주의할 점은 each에 들어가는 작업은 순차적이 아닌 병렬적으로 실행된다는 것입니다. 따라서 실행 순서를 보장하지 않기 때문에 예상한 결과가 나오지 않는 경우가 많습니다.반복문의 실행 순서가 중요한 경우 async.eachSeries를 사용하시면 됩니다. 하나의 작업이 다 끝나고 다음 작업을 순차적으로 실행하기 때문에 처리 속도가 상당히 느려지는 단점이 존재합니다.그 이외에 반복적으로 처리한 값을 하나의 결과로 전달받아야 하는 경우 async 함수 바깥쪽에 const agg = [] 와 같이 정의해서 결과값을 push 하는 것이 아닌 async.map 을 사용하면 간단하게 해결할 수 있습니다.whilst마지막으로 알아볼 메소드는 분기문인 whilst 입니다.12345678910111213let count = 0;async.whilst( (callback) =&gt; { callback(null, count &lt; 5) }, (callback) =&gt; { count++; setTimeout(function() { callback(null, count); }, 100); }, (err, n) =&gt; { console.log(err, n); });첫 번째 인자로 조건문을 받아들이며 두 번째 인자는 조건문이 true일 동안 실행되게 됩니다. 조건문이 false가될 경우 세 번째 인자로 받아들인 함수를 실행하게 되며 결과값도 함께 전달됩니다.끝으로이렇게 해서 기본적인 async 라이브러리의 사용 방법에 대해 알아보았습니다. 개인적으로는 Promise 나 async/await 보다 상당히 편해서 자주 사용하는 라이브러리입니다. 위에서 언급한 메소드만 잘 조합해도 대부분의 작업들은 문제없이 구현 가능하며 이외에도 다양한 메소드들을 제공하고 있으니 async 공식 documentation을 꼭 확인하시길 바랍니다.궁금한 점이나 피드백이 있다면 언제든지 알려주세요 ! document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Javascript/General/async%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90/"},{"title":"복잡한 분기문, if-else 이외에 다른 방법으로 구현하기","text":"if-else는 아주 오랜기간 동안 복잡한 분기문을 구현하는데 있어서 필수적으로 사용되어 온 존재입니다. 하지만 개인적으로는 이렇게 사용하기 편한 if-else문도 일정 복잡도를 넘어가면 코드가 복잡해지고 가독성이 떨어지는 상황을 많이 보게 되는데요. 최근들어 많은 프로그래밍 언어들의 지속적인 업데이트 및 다양한 syntax를 지원해줌에 따라 if-else 사용을 하지 않고 분기문을 구현할 수 있는 방법들이 많이 생겨나고 있습니다.기존의 사용 방식if-else먼저 일반적으로 우리가 배웠고 사용해온 if-else 입니다.1234567891011121314151617const log = (text) =&gt; console.log(text);const onClick = (status) =&gt; { if(status === 1){ log('처리중'); } else if(status === 2) { log('처리완료'); } else if(status === 3) { log('실패'); } else if(status === 4) { log('취소'); } else { log('오류'); }}onClick(1);버튼클릭 시 status 값에 따라서 console.log를 찍어주는 코드입니다. 일반적으로 코딩 공부를 할 때 가장 처음 배우는 코드이고 심플하고 직관적입니다. 똑같은 로직을 흔히들 많이 사용하는 switch로도 구현 할 수 있습니다.switch123456789101112131415161718192021const onClick = (status) =&gt; { switch (status){ case 1: log('처리중'); break case 2: log('처리완료'); break case 3: log('실패'); break case 4: log('취소'); break default: log('오류'); break }}onClick(1);위의 방법도 가독성도 좋고 간단하지만 더 간단하게 구현하는 방법도 있습니다.함수형 프로그래밍이나 ES6를 사용하시는 분들이라면 익숙한 방법인데요, 바로 object 의 key 값을 switch의 case 와 같은 형태로 사용하는 방법입니다.Object의 특징을 이용한 방식1234567891011121314const actions = { 1: () =&gt; log('처리중'), 2: () =&gt; log('처리완료'), 3: () =&gt; log('실패'), 4: () =&gt; log('취소'), default: () =&gt; log('오류'),};const onClick = (status) =&gt; { const action = actions[status] || actions['default'] action();}onClick(1);먼저 object 에 status값에 따라 실행할 수 있는 함수들을 value로 입력합니다. 그리고 입력된 status값에 따라 해당 값을 불러와서 실행해주게 됩니다. 값이 없을 경우 default값이 실행되도록 설정 할 수 있습니다.다른 일반적인 변수타입들과는 다르게 위 예제의 action 변수는 lazy 한 특성을 가지고 있습니다. 다시 말해 변수가 선언과 동시에 실행되는 것이 아닌, 해당 변수의 key에 해당하는 value 인 함수를 필요 할 때 실행할 수 있습니다.Map을 이용한 방식다음으로는 Map 을 이용하는 방법입니다.12345678910111213const actions = new Map([ [1, () =&gt; log('처리중')], [2, () =&gt; log('처리완료')], [3, () =&gt; log('실패')], ['default', () =&gt; log('오류')],]);const onClick = (status) =&gt; { let action = actions.get(status) || actions.get('default'); action();}onClick(1);object 와 비슷한 형태이지만 다른 특징들을 가지고 있습니다.object의 경우 prototype key를 항상 가지고 있습니다.Map의 key값은 어느형태나 가능하지만 object의 특성상 key값은 항상 숫자이거나 문자열 만 가능합니다.Map에서는 간단하게 size와 같은 attribute로 key-value를 가져올 수 있지만 object에서는 항상 수동으로 처리해 주어야 합니다.아래의 코드는 상태값 뿐만 아니라 유저의 권한에 따라서 다르게 구현하여야 하는 로직입니다.12345678910111213141516171819const onClick = (status,identity) =&gt; { if (identity === 'user') { if (status === 1) { } else if (status === 2) { } else if (status === 3) { } else if (status === 4) { } else if (status === 5) { } else { } }else if (identity === 'admin') { if (status === 1) { } else if(status === 2) { } else if(status === 3) { } else if(status === 4) { } else if(status === 5) { } else { } }}위에서 얘기한 Map 을 이용하게 되면 아래와 같이 간단하게 구현 할 수 있습니다.1234567891011121314151617181920const actions = new Map([ ['user_1', ()=&gt;{/*do sth*/}], ['user_2', ()=&gt;{/*do sth*/}], ['user_3', ()=&gt;{/*do sth*/}], ['user_4', ()=&gt;{/*do sth*/}], ['user_5', ()=&gt;{/*do sth*/}], ['admin_1', ()=&gt;{/*do sth*/}], ['admin_2', ()=&gt;{/*do sth*/}], ['admin_3', ()=&gt;{/*do sth*/}], ['admin_4', ()=&gt;{/*do sth*/}], ['admin_5', ()=&gt;{/*do sth*/}], ['default', ()=&gt;{/*do sth*/}],]);const onClick = (identity, status) =&gt; { const action = actions.get(`${identity}_${status}`) || actions.get('default'); action.call(this);}onClick('user', 1);onClick호출 시 유저의 권한과 status값을 같이 넣어주게 됩니다. 해당 값을들 전달받은 함수는 string형태로 actions에서 값을 불러와 실행하게 됩니다. 위의 if-else로 구현한 예제 처럼 권한과 상황에 따라 다른 방식으로 처리할 수 있도록 구분되어 있습니다.위의 방식이 잘못된것은 아니지만 key 값이 string으로 구현되어 있는건 뭔가 예외처리 등에 있어서 좋아 보이진 않습니다. 그럴 경우 아래와 같이 key값을 object 형태로 바꿔줄 수 있습니다.1234567891011const actions = new Map([ [{identity:'user',status:1}, ()=&gt;{log('A')}], [{identity:'user',status:2}, ()=&gt;{log('B')}],])const onClick = (identity,status)=&gt;{ const action = [...actions].filter(([key,value])=&gt;(key.identity == identity &amp;&amp; key.status == status)); action.forEach(([key,value])=&gt;value.call(this));}onClick('user', 1);actions에 정의되어 있는 값을들 spread operator 를 이용하여 단일 배열로 만들어 준 다음에 filter 를 이용하여 key에 정의되어 있는 identity와 status값이 동일한 값을 찾아냅니다. 찾아진 값 들은 배열로 반환되기 때문에 forEach 를 통하여 순차적으로 실행됩니다.주의할 점은 만약 identity 와 status값이 동일한 값이 2개가 들어 있다면 2개 모두 실행되게 됩니다. 상황에 따라 유용하게 사용 할 수 있습니다. ㅎㅎ123456789101112131415161718const actions = ()=&gt;{ const functionA = ()=&gt;{log('A')}; const functionB = ()=&gt;{log('B')}; return new Map([ [{identity:'user',status:1},functionA], [{identity:'user',status:2},functionA], [{identity:'user',status:3},functionA], [{identity:'user',status:4},functionA], [{identity:'user',status:5},functionB], ])}const onClick = (identity,status)=&gt;{ let action = [...actions()].filter(([key,value])=&gt;(key.identity == identity &amp;&amp; key.status == status)) action.forEach(([key,value])=&gt;value.call(this))}onClick('user', 1);만약 여러개의 key-value 에 해당하는 함수들이 동일한 기능을 수행해야 하는 경우는 어떨까요? 그럴 경우 해당 로직들을 미리 함수로 구현해둔 다음에 위와 같이 활용 할 수 있습니다.위의 예제에서 어차피 user 1 ~ 5 까지는 동일한 기능을 수행하게 됩니다. 따라서 해당 부분을 아래와 같이 바꿔서 사용할 수 있습니다.1234567891011121314const actions = ()=&gt;{ const functionA = ()=&gt;{/*do sth*/} const functionB = ()=&gt;{/*do sth*/} return new Map([ [/^guest_[1-4]$/,functionA], [/^guest_5$/,functionB], //... ])}const onButtonClick = (identity,status)=&gt;{ let action = [...actions()].filter(([key,value])=&gt;(key.test(`${identity}_${status}`))) action.forEach(([key,value])=&gt;value.call(this))}개인적인 의견으로는 코드를 줄일 수 있어서 좋긴 하지만 잘못하면 오히려 가독성을 떨어뜨리는 효과를 낳을 수도 있을것 같아 지양하는 방법입니다.끝으로이렇게 해서 if-else를 대체할 수 있는 방법들에 대해 알아보았습니다. 저 같은 경우 기존에 if-else 가 상당히 익숙해져 있어서 예시들과 같은 방법들을 사용하여 코드를 작성하고 익숙해지기 까지 어느정도 시간이 걸렸던것 같습니다. 프로그래밍도 결국 언어의 사용이기 때문에 다른 문법을 익히고 익숙해지기 까지 시간이 걸리는것은 어찌보면 당연한것 같습니다 :)ResourcesClean up your code by removing ‘if-else’ statementsThumbnail Photo by Christopher Robin Ebbinghaus on Unsplash document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Javascript/General/%EB%B3%B5%EC%9E%A1%ED%95%9C-%EB%B6%84%EA%B8%B0%EB%AC%B8-if-else-%EC%9D%B4%EC%99%B8%EC%97%90-%EB%8B%A4%EB%A5%B8-%EB%B0%A9%EB%B2%95%EC%9C%BC%EB%A1%9C-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/"},{"title":"Node.js에서 이메일 인증을 통한 비밀번호 초기화 기능 구현하기","text":"과거에는 (유독 한국만..ㅠㅠ) 비밀번호를 초기화하기 위해 휴대폰 번호를 인증해야 하는 경우가 많았습니다. 하지만 개발하는 서비스가 이메일 기능을 제공하는 등 특수한 상황이 아닌 이상 조금 더 user-friendly 하고 비교적 구현이 간단한 이메일 인증 방식을 사용하는 것이 개인적으로는 합리적이지 않나 생각됩니다.. ㅎㅎ이번 포스트에서는 Node.js에서 nodemailer를 이용하여 이메일 전송과 비밀번호 초기화 기능을 다루어 보도록 하겠습니다.절차비밀번호 초기화 절차는 위와 같습니다. 먼저 유저가 비밀번호 초기화 요청을 하게 된다면 서버에서는 인증키를 발급하게 됩니다. 발급된 인증키는 유저가 입력했던 이메일로 전송되며, 그와 동시에 데이터베이스에 ttl(유효기간) 값과 함께 저장됩니다.이메일을 통해 비밀번호 초기화 페이지로 접근한 유저는 초기화할 비밀번호와 인증키를 다시 서버로 전송하게 되며, 서버는 인증키 값과 비밀번호 유효성 등을 확인한 후 비밀번호 재설정 과정을 진행하고, 다시 유저에게 결과 값을 전달하게 됩니다.비밀번호 초기화 요청웹 페이지에서 유저가 비밀번호 초기화 이메일을 입력 했다고 가정하겠습니다. 프론트엔드에서는 아래와 같은 API를 호출하며 email을 전달하여 줍니다.1234567891011121314app.post('forget-password', (req, res) =&gt; { // email 입력 확인 if (req.body.email === '') { res.status(400).send('email required'); } // 유저 데이터베이스에 존재하는 이메일인지 확인 User.findOne({ where: { email: { like: req.body.email } } })});이메일을 입력받은 후 간단하게 이메일이 입력되었는지, 실제 데이터베이스에 존재하는지 확인하게 됩니다. 이메일 형식 확인 및 인증 메일을 보낼 수 있는 최대 횟수 제한 등은 예제에서 생략하도록 하겠습니다.인증 토큰 생성이메일을 입력받게 되면 서버에서는 인증키 역할을 할 토큰(token)을 생성하여 줍니다.1234567891011const crypto = require('crypto');User.findOne(...).then((user) =&gt; { const token = crypto.randomBytes(20).toString('hex'); // token 생성 const data = { // 데이터 정리 token, userId: user.id, ttl: 300 // ttl 값 설정 (5분) }; Auth.create(data); // 데이터베이스 Auth 테이블에 데이터 입력 })crypto를 이용하여 token을 생성하여 줍니다. 생성된 토큰을 ttl값과 함께 데이터베이스에 입력합니다. crypto는 Node.js 의 built-in module이기 때문에 별도의 패키지 설치가 필요 없습니다. ttl은 Time-To-Live의 약자로 토큰이 몇 초 동안 값이 유효할지를 정할 수 있습니다.생성된 토큰 이메일 전송생성된 토큰을 nodemailer package를 사용하여 해당 이메일로 전송합니다.프론트엔드에서 다루기 나름이지만 http://localhost/reset/ABCDEFGHIJK1234 와 같은 형식의 서브 URL 방식으로 전송하거나 GET 방식으로 http://localhost/reset/?token=ABCDEFGHIJK1234 와 같이 토큰값을 전달 할 수 있습니다.예시에서는 URL방식으로 토큰값을 전달하도록 하겠습니다.nodemailer 설치1npm install nodemailer12345678910111213141516171819const nodemailer = require('nodemailer');// nodemailer Transport 생성const transporter = nodemailer.createTransport({ service: 'gmail', port: 465, secure: true, // true for 465, false for other ports auth: { // 이메일을 보낼 계정 데이터 입력 user: 'test@gmail.com', pass: 'test', }, });const emailOptions = { // 옵션값 설정 from: 'test@gmail.com', to: 'user@gmail.com', subject: '비밀번호 초기화 이메일입니다.', html: '비밀번호 초기화를 위해서는 아래의 URL을 클릭하여 주세요.' + `http://localhost/reset/${token}`, }; transporter.sendMail(emailOptions, res); //전송이렇게 email을 전송하였습니다. 초기화 email을 받은 유저는 위의 링크를 통해 비밀번호 입력창으로 이동하게 되며 새로운 비밀번호를 입력하게 됩니다. 465포트를 사용하게 됨으로 firewall을 사용한다면 해당 포트가 열려있는지 확인하시길 바랍니다.비밀번호 재설정위의 작업까지 끝났다면 남은 작업들은 간단합니다. 유저가 입력한 비밀번호와 token값을 API로 받아들여 Auth 테이블에서 유효성을 확인한 후 유효하다면 비밀번호를 초기화하면 됩니다.개발하는 시스템마다 데이터베이스를 다루는 방법이 다르니 구체적인 코드는 생략하도록 하겠습니다.1234567891011121314151617app.post('reset-password', (req, res) =&gt; { // 입력받은 token 값이 Auth 테이블에 존재하며 아직 유효한지 확인 Auth.findOne({ where: { token: { like: req.body.token }, created: { greater: new Date.now() - ttl } } }).then((Auth) =&gt; { // 유저데이터 호출 User.find(...) }).then(user) =&gt; { // 유저 비밀번호 업데이트 User.update(...) }});기타 이슈들gmail을 통해 메일을 보내려고 하면 username and password not accepted 535 와 같은 애러메시지가 발생하는 경우가 있습니다. 이 경우 외부에서 gmail에 접근할 수 있도록 보안 설정을 변경해주어야 합니다.여기서 Less Secure App Access를 활성화시켜 해결할 수 있습니다.끝으로,이렇게 이메일을 통한 비밀번호 초기화 방법을 알아보았습니다.생성된 토큰이 만료된 후 URL에 접근하는 경우와 비밀번호 입력도 중 토큰이 만료되는 경우 등에 대해 별도로 토큰 유효성을 확인할 수 있는 API를 개발하는 것이 좋아보입니다.혹시 추가적인 의견이 있거나 피드백이 있다면 언제든지 연락 주세요.긴글 읽어주셔서 감사합니다 :) document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Server/Node-js/node-js%EC%97%90%EC%84%9C-%EC%9D%B4%EB%A9%94%EC%9D%BC-%EC%9D%B8%EC%A6%9D%EC%9D%84-%ED%86%B5%ED%95%9C-%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8-%EC%B4%88%EA%B8%B0%ED%99%94-%EA%B8%B0%EB%8A%A5-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/"},{"title":"Jekyll에서 검색엔진 최적화를 하는 10가지 방법","text":"아직은 블로그를 시작한 지 얼마 안 돼서 당연히 방문객도 많이 없고 검색엔진 최적화가 안되어 있지만 적어도 구글에서 제 블로그 주소를 검색했을 땐 상위 노출이 되도록 해야겠다는 생각이 들었습니다.블로그 운영의 목적은 개인적으로 공부했던 것들을 잊어버리기 전에 기록하기 위함이지만 공들여서 쓴 글을 누가 봐준다는 것은 좋은 일이니까요,, ㅎㅎSEO란 무엇일까 ?Search engine optimization (SEO) is the process of increasing the quality and quantity of website traffic by increasing the visibility of a website or a web page to users of a web search engine.위키피디아에서는 다음과 같이 정의하고 있는데요. 한마디로 말해 웹 페이지들이 검색엔진 결과에 상단 노출이 되도록 최적화하는 작업입니다. 아 물론 키워드 광고비를 쏟아부어서 상단 노출시키는 방법도 있지만 여기서는 순수한 검색 결과에 노출되는 방법에 집중하도록 하겠습니다.그래서 SEO가 잘된 페이지는?출처 위키피디아위키피디아를 예로 들면 각각의 페이지가 하나의 토픽에 대해 여러 방면으로 깊게 다루고 있습니다. 한국의 치맥 문화와 역사에 대해 깊게 다루는 웹사이트는 쉽게 찾아볼 수 없기 때문에 검색엔진은 위의 페이지의 랭킹을 높게 매기게 됩니다.컨텐츠 이외에도 페이지의 title tag와 페이지 URL 및 페이지 내 heading 이 모두 Chimaek이라는 같은 이름으로 통일되어 있으며, image alt tag 역시 페이지와 연관된 내용이 입력되어 있습니다.본격 SEO하기이제 Jekyll로 만들어진 웹사이트의 SEO를 하는 방법에 대해 알아보겠습니다1. 제목과 설명웹사이트 내 각각의 페이지에 제목과 설명글을 입력하는 것은 어찌 보면 당연한 일이지만 그만큼 아주 중요합니다.검색을 했을 때 검색 결과에 노출되는 제목과 설명에 따라 검색자가 찾고 있는 내용과 목적에 부합하는지 바로 판단이 가능하기 때문입니다. 마치 유튜브에서 썸네일과 제목만으로 해당 비디오를 클릭할지 안 할지 결정하는 것과 같은 맥락입니다.또한 구글의 Search Engine Bot은 웹페이지들을 indexing 할 때 제목과 설명글을 먼저 확인하기 때문에 빠져서는 안 되는 부분입니다.Title 설정하기1234567&lt;title&gt; {% if get_page_title() %} {{ get_page_title() }} {% else %} {{ get_site_title() }} {% endif %}&lt;/title&gt;각각의 page에 정의된 title이 있다면 그대로 사용하고 없다면 _config.yml 에 입력한 title 을 가져오는 함수를 만들어 head에 입력해 줍니다.Description 설정하기123&lt;meta itemprop=\"description\" name=\"description\" content=\"{% if page.description %}{{ page.description | truncate: 160 }} {% else %}{{ site.description | truncate: 160 }}{% endif %}\" /&gt;description은 항상 160자 이내로 유지해줍니다.jekyll로 만들어진 많은 페이지들이 description 뿐만 아니라 keyword를 meta tag에 입력하도록 되어 있는데요. 2009년부터 구글에서는 keyword meta tag를 ranking에 사용하지 않겠다고 공표하였습니다.관련 자료는 여기를 참고하시면 됩니다.2. URL 구조URL구조는 아주 중요한 역할을 합니다. 웹사이트를 공유하였을 때 URL만 보고 무슨 내용인지 바로 확인이 가능하도록 설정하는 것이 좋습니다.12https://techlog.io/Javascript/General/async라이브러리에-대해-알아보자/ // 잘된 URL 설정https://techlog.io/3213/?read=2&amp;id=1 // 안좋은 URL 설정또한 URL은 위와 같은 상하(Hierarchy) 관계의 디렉토리를 유지하는 것이 좋습니다. 잘된 URL의 예를 보면 해당 포스트가 대분류로는 Javascript에 해당되며 소분류로는 General에 해당하는 것을 알 수 있습니다.각 웹페이지에 대한 indexing은 search engine이 하지만 결국 해당 링크를 보는 것은 사람이므로 URL에 간결하고 명확한 정보를 담도록 합니다.3. sitemapsitemap은 웹사이트의 전체 구조를 담고 있습니다. sitemap을 사람이 볼일은 극히 드물지만 Search Engine Bot들은 sitemap의 데이터를 이용하여 해당 사이트의 구조를 파악하게 됩니다. jekyll에서는 매번 게시글을 등록하고 사이트의 구조가 바뀔 때마다 일일이 sitemap을 설정하지 않아도 자동으로 처리해주는 plugin이 존재합니다.plugin 설치1gem 'jekyll-sitemap'_config.yml123url: \"https://example.com\" # the base hostname &amp; protocol for your siteplugins: - jekyll-sitemap위와 같은 방법으로 plugin 설치가 가능하며 page deploy후 https://example.com/sitemap.xml 에서 확인이 가능합니다.4. Image alt Tagsimage alt tag란 평소에는 볼일이 없지만 만약 네트워크 상황 등에 의하여 이미지를 표시할 수 없을 때 출력되는 텍스트입니다. Search Engine Bot은 각각의 이미지의 alt tag를 확인하기 때문에 각각의 이미지마다 반드시 관련된 내용을 입력해주는 것이 좋습니다.1&lt;img alt=\"seo\" title=\"seo example\" src=\"/gallery/seo-example.jpg\"&gt;5. 소셜 연결하기각각의 포스트들이 소셜 네트워크 서비스에 쉽게 공유될 수 있도록 소셜 버튼을 제공합니다.자세한 방법은 여기를 확인해주세요.6. Open Graph Tags포스트를 공유하는 버튼을 만들었으니 이제 공유가 되었을 때 표시는 되는 내용에 대해 작업할 차례입니다.소셜 사이트에 링크가 공유되었을 때 출력되는 내용은 og tag를 통해 입력할 수 있습니다. og tag에는 페이지의 제목과 내용, 타입, 그리고 가장 중요한 썸네일 이미지가 입력됩니다.설정이 완료된 후 페이스북에서 제공하는 Sharing Debugger 또는 트위터의 Card Validator를 통해 확인 가능합니다.techlog.io 의 경우 위와 같이 표시됩니다.7. favicon과 touch icons대부분의 사람들은 웹사이트를 떠올릴 때 이름보다는 로고나 해당 웹사이트가 가지고 있는 아이덴티티에 대해 먼저 떠올리게 됩니다. 유튜브는 빨간색 버튼, 페이스북은 파란색 F 모양 아이콘처럼 먼저 떠오르는 이미지들이 있습니다.크롬 브라우저 탭의 상단에 표시되는 아이콘 및 북마크에 표시되는 아이콘을 favicon 이라고 부릅니다. facivon의 확장자는 ico 이며 대체적으로 16x16 의 해상도를 가지고 있습니다.운영 중인 웹사이트의 특색을 가장 잘 나타내는 favicon은 아주 중요한 역할을 합니다.8. 일관된 URL일관된 URL은 검색을 하고 있는 사람에게도 중요하지만 웹 페이지들을 indexing하고 ranking을 매기는 Search Engine Bot에게도 아주 중요한 작용을 하게 됩니다.12https://techlog.io/Javascript/General/async라이브러리에-대해-알아보자https://techlog.io/Javascript/General/async라이브러리에-대해-알아보자.html위의 두 URL은 언뜻 보면 같아 보이지만 Search Engine Bot에게는 전혀 다른 URL로 인식됩니다.또한 URL앞에 www 붙이는 것과 붙이기 않는 것 둘 중 하나도 통일하는 것이 좋습니다.9. 반응형 (mobile friendly layout)2015년 4월 21일부터 구글은 반응형 웹사이트를 ranking을 매기는 인자로 추가하게 되었습니다. 다행히도 친절한 구글에서는 이를 테스트할 수 있는 기능을 여기서 공식적으로 제공하고 있습니다.또한 모바일 검색엔진 최적화에 관한 공식문서를 확인하시길 바랍니다.10. google search console마지막으로 아주 중요한 작업이 남아 있습니다. 바로 googel search engine에 자신의 웹 사이트가 존재한다는 것을 알려주는 것인데요. google search console에서 이 작업을 할 수 있습니다.이곳에서 웹사이트를 등록하고 위에서 생성한 sitemap.xml을 등록해두시면 일정 주기에 따라 해당 웹사이트를 indexing 하고 유입되는 트래픽을 관찰하여 줍니다.필수는 아니지만 이곳에 url과 sitemap 등록이 완료되면 구글에서 site:http://www.example.com 와 같이 검색하였을 때 해당 웹사이트가 검색되는 것을 확인하실 수 있습니다.robots.txtSearch Engine Bot이나 crawling을 하는 bot의 경우 크롤링 전 해당 사이트의 robots.txt 파일을 먼저 확인하게 됩니다. 이곳에서는 크롤링에 대한 정책을 명시하는 곳입니다. 크롤링에 대한 모든 접근을 deny 한다면 Search Engine Bot 역시 해당 웹사이트의 내용을 가져오지 못하게 됩니다.저 같은 경우는 아래와 같이 모두 허용 처리를 해두고 사이트맵 위치도 명시해두었습니다.https://techlog.io/robots.txtrobots.txt123User-agent: *Allow: /Sitemap: https://techlog.io/sitemap.xml끝으로이렇게 해서 jekyll로 된 웹사이트를 SEO 하는 방법에 대해 알아보았습니다. SEO란 프로그래밍적, 소프트웨어 적으로 최적하는 하는것뿐만 아니라 사람이 보았을 때 사이트로 유입이 되도록 하는 행위 역시 포함됩니다.따라서, 무슨 사람들이 어떤 정보를 찾고 있고, 그에 따른 검색어는 무엇을 사용하고 있으며 무슨 컨텐츠를 소비하고 싶어 하는지를 먼저 생각하는 것이 선행되어야 한다고 생각되네요.. :)긴 글 읽어주셔서 감사하며 질문이나 피드백이 있다면 언제든지 알려주세요 !Resources10 Must do Jekyll SEO optimizationsgoogle-friendly siteOn-Page Ranking Factorshttps://www.siteleaf.com/blog/seo-with-jekyll-siteleaf/ document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/Programming/jekyll%EC%97%90%EC%84%9C-%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84-%EC%B5%9C%EC%A0%81%ED%99%94%EB%A5%BC-%ED%95%98%EB%8A%94-10%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95/"}],"tags":[{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"Security","slug":"Security","link":"/tags/Security/"},{"name":"Wireshark","slug":"Wireshark","link":"/tags/Wireshark/"},{"name":"Async","slug":"Async","link":"/tags/Async/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"Server","slug":"Server","link":"/tags/Server/"},{"name":"SEO","slug":"SEO","link":"/tags/SEO/"}],"categories":[{"name":"Server","slug":"Server","link":"/categories/Server/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"HTTPS","slug":"Server/HTTPS","link":"/categories/Server/HTTPS/"},{"name":"Node.js","slug":"Server/Node-js","link":"/categories/Server/Node-js/"},{"name":"Programming","slug":"Programming","link":"/categories/Programming/"},{"name":"General","slug":"Javascript/General","link":"/categories/Javascript/General/"}]}